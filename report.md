# 计概 A 大作业（黑白棋）报告

> 2016 年 1 月 3 日

## 概述
* 本黑白棋程序（下称 Othello）实现了下棋、存档、读档、悔棋等功能。此外，Othello 还实现了 GUI 界面；此外，还实现了掀棋子等彩蛋。
* 参阅环境对应 Release 分支的 README 文件；

## Othello 的结构
下面，我们来深入 Othello，探究程序的实现与设计。首先，我们来总览 Othello 的结构。

* 整个程序的状态储存在 `Game` 类的静态变量中，而游戏的流程控制由调用 `Game` 的静态函数实现。
* 整个程序调用两个线程，分别是游戏与绘图线程。游戏线程负责CLI部分的全部游戏控制，而绘图线程仅负责绘图与GUI模式下的输入。

## Othello的类的实现
### `Status` 枚举类型
* `Status` 枚举类型不仅表示了棋子的颜色，也表示了游戏流程的控制状态；

### `Piece` 类
* `Piece` 类实现了 Othello 中棋子的储存；
* `Piece` 类储存了棋子的横纵坐标及棋子颜色；

### `Board` 类
* `Board` 类实现了 Othello 中棋盘的储存；
* `Board` 类不仅储存了每一个坐标位置上棋子的状态，还缓存了双方棋子个数、可下子情况，以及下棋历史记录；
* `Board` 类的成员函数不仅包括获取棋盘信息的函数，也包括落子函数、悔棋函数、调试打印函数，以及从文件重建棋盘状态函数；

### `Player` 类
* `Player` 类实现了 Othello 双方棋手的表示与储存；
* `Player` 类的成员变量储存了玩家的执子黑白与是否为人类；
* `Player` 类大多数的成员函数为虚函数；

### `AI` 类
* `AI` 类继承自 `Player` 类；
* `AI` 类重写了父类虚方法，包括取子函数；

### `Game` 类
* `Game` 类的所有对象均为静态，为整个 Othello 的数据库；
* `Game` 类的静态变量有棋盘 `Board b`，落子方 `bool sideFlag`，游戏状态 `Status gameStatus` 等；
* `Game` 类的静态方法涵盖了游戏状态控制、获知游戏信息等方面，极大地抽象了游戏控制接口，具有很好的移植性；

### `Settings` 类
* `Settings` 类变量是游戏的设置开关；
* `Settings` 类变量均公开，且为静态变量；

### ` Stones` 类
* `Stones` 类主要在图形界面绘制时使用；
* `Stones` 类较 `Piece` 类还多储存了棋子在空中翻转时的速度、位置、角速度、角位置以及转轴等状态；

## Othello 其他头文件的作用
### `base.h`
* 定义程序常量，以及各实用内联函数；

### `display.h`
* `display.cpp` 函数声明

### `io.h`
* `io.cpp` 函数声明

## Othello 游戏状态转移过程
### `Idle` 状态
* 等待玩家选择游戏模式；
* 游戏初始化/重置后进入 `Idle` 状态；
* 当玩家确定游戏模式后，由 `int Othello_main(int, char**)(main.cpp:27)` 开启对应游戏线程，并等待线程结束返回；状态将转移至 `Playing`；

### `Playing` 状态
* 正常游戏过程状态；主要由 `void Othello_game(int, int)(main.cpp:92)` 负责游戏进行；
* 当用户按下 `Esc` 暂停时（图形输入模式）/当用户输入 `m` 进入菜单界面时（非图形输入模式），状态转移到 `Pause`；

### `Pause` 状态
* 此时游戏暂停，图形界面显示选项菜单；用户将在对应模式下进行菜单选取并交互；
* 根据用户选择的不同，状态会进入 `Playing` 或者是 `End`；

### `End` 状态
* 当棋终或者是用户因为保存并退出等操作，使游戏不得进行的时候，将会进入此状态；
* 在 `void Othello_game(int, int)(main.cpp:92)` 检测到此状态后，它会退出回到 `int Othello_main(int, char**)(main.cpp:27)`；

### `Lifting` 状态
~~**前方高能，非战斗人员请迅速撤离！**~~

~~**再强调一遍，这不是演习！**~~
* 当用户认为棋局对自己不利时，而且处于 `Playing` 状态时，按下 `l` 键将进入本状态；
* 在本状态时，主要是由 `void timerCallback(int)(model.cpp:99)` 负责刷新棋子状态并调用绘图函数刷新屏幕内容；
* 默认 10 秒后自动转移到 `End` 状态；

### `Recovery` 状态
* 在本状态下，程序读档恢复棋局；

## Othello 的功能
### 下棋
* 在命令行输入时，`Piece getPieceFromConsole(bool)(io.cpp:22)` 先会判断输入内容是否具有特定含义；如果有，将返回具有状态码的棋子（如悔棋，菜单，存档等）；否则，分析并返回对应的棋子；
* 在图形界面输入时，`Piece getPieceFromMouse(bool)(io.cpp:382)` 返回一个由鼠标确定的棋子；

### 悔棋
* 通过用两个 `unsigned long long int` 来储存棋盘状态，这样就能方便进行悔棋操作了；
* 悔棋时，先判断是否有AI参与；如果有的话，将会退回到最近一步人类可以下的一步；

### 存/读档
* 当用户存/读档时，`int save(io.cpp:191)`/`int readRecord(io.cpp:223)` 将会将当前局面写入/覆盖；

### (╯‵□′)╯︵┻━┻~~实现了一部分的~~掀桌子
* 建立了一个较为精确的物理模型处理棋子的运动与碰撞；
* 检测键盘状态，决定是否进入子弹时间；
* 灯光、雾效果的控制，视角的调整都有所涉及；

## Othello功能的实现方法
### `main.cpp`
* `int main(int, char**)(main.cpp:18)` 方法建立了绘图线程，随后将主线程控制权移交 `int Othello_main(int, char**)(main.cpp:27)`；
* `int Othello_main(int, char**)(main.cpp:27)` 方法实现了游戏主屏菜单；
	* 先判断是否有存档；如果有，将显示从存档恢复游戏的选项；
	* 随后打印选项列表；
	* 根据玩家选择模式之差异，向 `void Othello_game(int, int)(main.cpp:92)` 传递不同的参数；
* `void Othello_game(int, int)(main.cpp:92)` 实现了黑白棋下棋循环的控制；
	* 首先根据传入的参数建立 `player0` 与 `player1`，并存于数组中；
	* 接下来进入落子循环，只要游戏可以继续就进入循环：在打印棋盘后，判断玩家是否可以落子；如果可以，循环读入坐标直至落子有效；
	* 跳出落子循环后判断游戏是否被意外停止（如存档退出、掀棋子~~(╯‵□′)╯︵┻━┻~~等），如果不是的话输出胜负情况；
	* 删除为玩家分配的内存空间；

### `Othello_submit.cpp`
* 本文件是为BotZone比赛而精心精简优化的版本，包括了一个由位运算实现的棋盘，以及一个初步智商的AI；我们着眼于AI部分；
* `int eval(bool, int)(Othello_submit.cpp:294)` 是 Watch_Doge 实现判断的核心函数，基本实现方法是最大最小算法与 alpha-beta 剪枝：
	* 首先检查搜索层数是否耗尽；如果是，由`int getEvaluation(bool)(Othello_submit.cpp:277)`返回叶节点估值；
	* 如果己方无行动力，则判断为一个极不有利的局面，返回一个负值极大的估值；
	* 否则，遍历所有可下的位置，递归调用自身，分别取得对应位置的估值，取估值最大的位置并返回对应的估值；
	* 剪枝的实现：如果取得的估值，比父节点目前搜索的最大值的负值要大的话，那么可以进行剪枝（因为返回给上层的估值会被取负号，即父节点得到的返回值必定比最大值小）；为了最大化剪枝的效用，在遍历节点的时候是按照经验顺序的，储存在 `const int seq(Othello_submit.cpp:268)` 中；
    
### 其他
* 为了实现本项目的3D功能，项目中还有很多相关的函数；在此就不一一详解了。
